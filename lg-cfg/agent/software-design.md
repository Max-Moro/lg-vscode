# Принципы дизайна и проектирования

## Принцип "high cohesion low coupling"

Принцип высокого сцепления и низкой связанности — является основным и самым важным при построении логики программного продукта. Мы стараемся мысленно представить картину:
- операторы, функции и методы — это набор точек
- файлы (модули) и пакеты — это крупные круги (множества), группирующие точки
- вызовы методов и функций, импорты (зависимости) — это линии, соединяющие точки и множества

Представив данную картину, необходимо стараться так структурировать логику, чтобы по итогу кодовая база выглядела, как совокупность очень плотных и хорошо сцепленных точечных кластеров, который имеют очень мало внешних связей (зависимостей) с соседними, такими же плотными кластерами. Внутри множества много линий, между множествами — редкие линии.

Соблюдение данного принципа позволяет грамотно организовывать логику по классам и файлам, в свою очередь файлы группировать по пакетам, а пакеты выстраивать в более крупные иерархии (пакетные модули).

Принцип "high cohesion low coupling" тесно связан со своевременным выявлением и пресечением появления антипаттерна "божественный класс" или "божественный модуль" (файл), у которых раздутая ответственность, а значит низкое сцепление, но, возможно, высокая связанность. Можно выявить некоторые синтетические метрики: модуль меняется «по любому поводу», часто конфликты при мерджах, высокий фан-ин/фан-аут. Верно и обратное. Иногда после рефакторинга можно обнаружить вырожденные модули, состоящие только из одной функции, — это кандидаты на переезд в другой, более крупный модуль.

Высокое сцепление тесно связано с принципом SRP (из SOLID). Соблюдая одно, мы обычно сразу соблюдаем и другое.

Низкую связанность можно добиться не только разделением модулей, но и введением дополнительных интерфейсных абстракций. Тут мы обнаруживаем прямую связь между принципами "Interface Segregation" и "Dependency Inversion" (из SOLID). Клиенты не должны зависеть от интерфейсов, которые они не используют. Модули верхнего уровня не должны зависеть от модулей нижнего уровня; оба должны зависеть от абстракций.

## Принцип DRY

Это второй по важности принцип, который необходимо соблюдать при развитии кодовой базы.

При работе над новой функцией всегда есть соблазн действовать прямолинейно:
- напишу по образцу и подобию;
- нашел хороший пример, сделай, как там;
- скопирую данный участок кода и подправлю под свои нужды;
  Подобные действия сразу создают технический долг — нарушение принципа DRY.

Вместо этого, необходимо сразу оценить, как лучшим образом унифицировать и переиспользовать общий участок логики:
- вынос общей функции или метода;
- выделение общего родительского класса;
- использование любых других паттернов в сложных ситуациях: декорирование, проксирование, функции обратного вызова и так далее;

Для DRY часто дополнительно уточняется правило "трех". Лучше прямолинейно им не руководствоваться, а оценивать комплексно. Даже два раза продублированные 100 строк идентичной логики — это довольно плохо. А вот дублировать 5 раз по 3 строки — нормально. Это не жесткие эвристики, нужно всегда думать своей головой.

## Принцип разделения по уровням универсальности

При работе над текущей задачей часто обнаруживается, что не хватает некоторой небольшой утилиты или простого инструмента. Возникает соблазн быстро его имплементировать и положить рядом с бизнес логикой. Но мы забываем, что данная вещь универсальная и может пригодиться в будущем и на других участках.

Необходимо сразу производить разделение логики по уровням универсальности:
- системные и прикладные слои;
- универсальные утилиты и конечная бизнес логика;
- абстрактные каркасы и частные случаи;

Такой подход способствует лучшей перспективе переиспользования кода.

Есть более конкретные именованные подходы, которые соблюдают данный принцип: порты-и-адаптеры/гексагональная архитектура. Но мы сейчас не вдаемся в брендированные каракасы, а пытаемся сформулировать более универсальные принципы.

## Принцип ортогонального развития

Необходимо стараться выстраивать такую архитектуру системы, чтобы ее можно было улучшать и развивать в разных направлениях. И делать это довольно независимо — с минимальными мердж конфликтами. В хорошей спроектированной кодовой базе бизнес функции должны добавлять локализованно: в один модуль или пакет. Избегается размазанное добавление функционала в десятки файлов.

Если поступающие новые требования не позволяют удобным образом (локализованно) интегрировать их в текущую кодовую базу, то это является верным признаком неподходящей структуры. Возможно, стоит повременить с развитием бизнес логики и подумать о переработке архитектуры. Чтобы не накапливать технические долги в будущем.

Приведем пример. Файл (модуль) с общими константами приложения, кажется, что с одной стороны является хорошей идеей — избавляет код от магических значений. С другой стороны, сильно нарушает принцип ортогонального развития — данный модуль будет меняться постоянно, в результате любых изменений в логике. Более корректный подход — «feature-scoped settings».

## Какие общепринятые принципы мы осознанно нарушаем

Хорошо, это был кликбейтный заголовок — точнее не всегда следуем им бездумно.

«Совместимость: не ломай публичные API без версионирования/миграций». Да, казалось бы, хорошая штука, но его соблюдение ведет к грязному коду. Нужно оценивать ситуацию, что мы именно делаем. Если мы разрабатываем публичную библиотеку или публичную WEB-службу — это одна ситуация. Если наш код весь внутренний — это совершенно другая ситуация, при которой выгоднее делать полностью законченные рефакторинги, чем оставлять обратную совместимость.

«KISS & YAGNI». Это не плохие принципы. Но они слишком простые, в них нет четких критериев. Обычно AI-агент не знает, в какую сторону будут развиваться далее требования к системе. Для AI-агента аналитик — это человек, который с ним работает. По этой причине лучше посоветоваться с пользователем и явно спросить, нужен ли тот или иной рефакторинг, или же это будет усложнение на пустом месте.

## Быть живым разработчиком

Это уже даже не принцип дизайна и проектирования программного обеспечения, а скорее общая рекомендация к поведению. При итеративной разработке постоянно поступают новые требования, запросы нового функционала и даже инициативы по созданию новых крупных функциональных блоков.

Но не нужно бросаться и как робот, сразу начинать конкретно и прямолинейно решать поставленную задачу. Необходимо действовать как живой разработчик. Сперва нужно оценить, а готова ли текущая архитектура принять новую порцию необходимых изменений? Возможно, перед имплементацией бизнес функции, стоит сделать ряд подготовительных рефакторингов, чтобы соблюсти все перечисленные выше принципы.

Может быть и ситуация наоборот. Уже после имплементации новых требований, мы можем заметить возникшие проблемы и дурно пахнущий код. Тогда стоит сразу сделать улучшающий рефакторинг, чтобы не накапливать технические долги.

Живому разработчику также свойственен прагматичный подход. И даже в какой-то степени полезная лень. Все рефакторинги и улучшения он делает, не рази святой цели добиться идеальной чистой архитектуры. Он понимает, что систематизированные улучшения помогут ему в будущем проще работать с кодовой базой. Но тут важно не перестараться. Применение любого паттерна или принципа может вести к оверинжинирингу. Если запрошенная бизнес функция реализуется всего 10 строк, а для улучшения архитектуры потребуется 500 строк нового кода, то, конечно, это сомнительный рефакторинг.

## Советоваться с живым пользователем

Мы понимаем. Что при AI-Driven подходе разработку с достаточно глубоким уровнем автоматизации и самостоятельности ведет AI-агент. Он может пытаться быть "живым" исполнителем и пытаться соблюдать все перечисленные выши принципы, но конечно, бывают сложные и неоднозначные ситуации. Не нужно игнорировать возможность в любой момент остановить разработку и просто посоветоваться с реально живым пользователем в диалоге. Такое совместное обсуждение значительно снизит вероятность негативного ревью результирующего кода. Совместное своевременное планирование всего лучше, чем отдельные задачи по переработке архитектуры.