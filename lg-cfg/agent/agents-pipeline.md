# Пайплайн работы в данном проекте

## Важные особенности субагентов

**Изоляция контекста**: Каждый вызов субагента - отдельный сеанс. Агенты не помнят предыдущие выполнения. Это экономит токены, но требует полных инструкций в каждом промпте.

**Отчеты - единственная обратная связь**: Агент возвращает только финальный отчет. Невозможно задать уточняющие вопросы после выполнения.

## Доступные агенты

### Агент: @code-integrator

Ты дорогая, но умная модель. Ты хорошо планируешь архитектуру и пишешь код, но довольно расточительно при твоей работе вызывать множество операций (Read, Edit, Glob, Grep) чтобы сделать итоговую интеграцию намеченных изменений в конечную кодовую базу. Гораздо выгоднее распределить обязанности между тобой и субагентом-интегратором.

Тебе не нужно использовать инструменты для редактирования конечного кода. Просто напиши реализацию в виде единого Markdown-документа (единой подробной инструкции), чтобы ею могла воспользоваться более дешевая (глупая) AI-модель, но уже имеющая доступ к редактированию кодовой базы.

Поэтому в итоговой development-инструкции для субагента-интегратора (в "Subagent System Prompt") в основном должны быть технические детали реализации:
- короткое бизнесовое ТЗ;
- требуемые изменения в архитектуре (если они нужны);
- основные и оптимальные точки интеграции нового функционала;
- новые листинги кода в виде fenced-вставок;
- описание патчей (они могут быть не формальными, а просто достаточными для понимания другой AI-моделью);
- **при изменении публичных API** - явное указание ВСЕХ файлов, использующих эти функции/типы;
- и так далее;

Инструкция должна быть написана единоразово при запуске инструмента работы с агентом @code-integrator. Ни в коем случае не дублируй данную инструкцию в диалог с пользователем.

После окончания работы субагента-интегратора необходимо:
1. Извлечь секцию "Modified Files:" из его отчета
2. Передать список файлов агенту @linter в формате:
   ```
   Modified files:
   - path/to/file1.ext
   - path/to/file2.ext
   ```
3. Передать список файлов агенту @compiler с краткими комментариями о внесенных изменениях (на основе твоего исходного плана).

### Агент: @linter

Данный агент занимается вызовом линтера и исправление возникших проблем. Ему необходимо передать список измененных/созданных файлов. 

### Агент: @compiler

Данный агент занимается компиляцией кода и исправление возникших проблем. Ему необходимо передать список измененных/созданных файлов с краткими комментариями о том, что было изменено. Это нужно, чтобы агент компиляции осознанно производил исправления, а не просто случайно удалял полезный (только что добавленный) функционал.

Комментарии формируются оркестратором на основе исходного плана изменений (например: "added processDocument method", "updated to use new API").

### Прочие агенты

В данном проекте пока что используются только 3 агента:
- @code-integrator
- @linter
- @compiler

В проекте нет специального агента тестирования, потому что на данном этапе разработки все тесты делаются вручную пользователем (визуальное тестирование).

## Виды итераций

В зависимости от сложности задачи, работу над ней можно вести следующими способами.

### Основной итерационный цикл

#### Когда применять

- крупные рефакторинги и переработка архитектуры
- изменения в 3-х и более файлах
- необходимость полного переписывания некоторого существующего модуля
- обычно используется в начале диалога при работе над новой задачей или функцией

#### Порядок работы

1. Проверить достаточность данных в контекстном окне, полученных от инструмента **Listing Generator**. Если данных не достаточно для выполнения задачи, то остановить работу и сообщить пользователю.
2. Произвести первичное планирование работы над новой функцией или новым функциональным блоком.
3. Составить development-инструкцию и отправить ее в агента @code-integrator.
4. Произвести проверку измененной кодовой базы линтером через вызов агента @linter.
5. Произвести компиляцию кодовой базы через вызов агента @compiler.
6. Получить все отчеты от субагентов и разрешить их проблемы, если они у них возникли.
7. Составить для пользователя итоговое краткое саммари по результату работы над итерацией и отправить его диалог.
8. Завершить работу и ждать от пользователя обратную связь и/или результаты тестирования.

### Краткий итерационный цикл

#### Когда применять

- точечные исправления в 2-х и менее файлах
- локальное исправление проблем и ошибок
- обычно используется, когда пользователь продолжает работу в диалоге и дает обратную связь в результате тестирования
- данный тип итерации необходимо, чтобы вести ускоренную разработку

#### Порядок работы

1. Для ускорения необходимые минимальные исправления внести самостоятельно, без использования агента @code-integrator.
2. **ОБЯЗАТЕЛЬНО** запустить агента @linter для измененных файлов.
3. **ОБЯЗАТЕЛЬНО** запустить агента @compiler для проверки сборки.
4. Получить все отчеты от субагентов и разрешить их проблемы, если они у них возникли.
5. Быстро ответить пользователю, что исправление готово для тестирования (визуальной проверки). Комплексное саммари в этом случае уже писать не требуется.

**Важно:** Даже в кратком цикле нельзя пропускать проверку линтером и компилятором. 

### Общие правила работы

Нужно всегда принимать решение в зависимости от сложности задачи, по какому типу итерации с ней работать (основная или краткая).

В любом случае никогда не стоит создавать по своей инициативе итоговые Markdown-документы в файловой системе: саммари, чеклисты, отчеты по проделанной работе и так далее. Вся отчетность в конце итераций только в диалог. Если в результате работы над функциональным блоком очевидным образом устаревает уже существующая документация в репозитории, то не следует ее самостоятельно патчить, просто этот нюанс нужно обозначить пользователю.

Markdown-документацию необходимо разрабатывать, только если пользователь об этом специально отдельно попросит.

#### Обработка эскалаций от субагентов

Если субагент (@linter или @compiler) вернул статус "⚠️ Требуется внимание":

1. Прочитать секцию "Remaining errors" в отчете субагента
2. Оценить сложность проблемы:
   - **Простая** (1-2 файла, очевидный фикс) → Исправить самостоятельно через Edit и повторно запустить субагента
   - **Сложная** (требует рефакторинга, архитектурных изменений) → Остановиться и сообщить пользователю
3. Если проблема остается после 2-х итераций исправлений → остановиться и сообщить пользователю

#### Использование TodoWrite

TodoWrite используется **только оркестратором** для планирования работы над задачами.

Субагенты **НЕ используют** TodoWrite — они работают по четким инструкциям и сразу переходят к выполнению.